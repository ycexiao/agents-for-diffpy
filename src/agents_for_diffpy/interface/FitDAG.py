import networkx as nx
import uuid
from networkx.readwrite.json_graph import node_link_data
import json


class FitDAG(nx.DiGraph):
    """A directed acyclic graph (DAG) representing fitting instructions.

    Each dag corresponds to a single fitting task. A task that can been
    completed using only one instance of the corresponding adapter. In case
    of PDFAdapter which uses diffpy.srfit as the backend, a task is what can
    be completed using a single instance of the FitRecipe.

    DAG is only for data container purpose. The fit instructions is contained
    in "actions" and the final fit results in each step is contained in
    "payload". Intermedaite results like current residual generated by
    adapters should be access at FitRunner level.


    Node Attributes
    ----------------
    description: str
        The string description of the current node
    action: list
        The list of operations being executed in the current node. It will be
        used by the adapter to generate the action to be executed.
    payload: list
        Mostly the parameter values after the fitting at the current step
        is completed. Usually the payload from the parent node will be used
        as the starting point for the current node.
        It can also stores other results as irrelevant key-value
        pairs will be ignored by the adapter.

    Edge Attributes
    ---------------
    description: str
        The string description of the current edge
    """

    def __init__(self):
        super().__init__()
        # Used to template the default node and edge attributes
        self.default_node = {
            "description": "",
            "id": "",
            "name": "",
            "buffer": {},
            "payload": {},
            "action": [],
        }
        self.default_edge = {
            "description": "",
            "source": None,
            "target": None,
        }
        # Metadata for the current running state of the DAG.
        # Used by FitRunner.
        # Can be ignored if the DAG is only used as a static data container.
        self.name_to_id = {}

    @property
    def root_nodes(self):
        return [
            node_id for node_id in self.nodes() if self.in_degree(node_id) == 0
        ]

    @property
    def leaf_nodes(self):
        return [
            node_id
            for node_id in self.nodes()
            if self.out_degree(node_id) == 0
        ]

    def _update_name_to_id(self):
        for node_id, node_content in self.nodes(data=True):
            self.name_to_id[node_content["name"]] = node_id

    def furnish_node_dict(self, node_dict):
        """Make the arbitrary node dictionary conform to the default node
        template."""
        template_node = self.default_node
        node_dict = {
            key: (
                node_dict[key]
                if key in node_dict.keys()
                else template_node[key]
            )
            for key in template_node.keys()
        }
        name = (
            node_dict["name"]
            if node_dict["name"] != ""
            else ", ".join(node_dict["action"])
        )
        node_dict["name"] = name
        return node_dict

    def furnish_edge_dict(self, edge_dict):
        """Make the arbitrary edge dictionary conform to the default edge
        template."""
        template_edge = self.default_edge
        edge_dict = {
            key: (
                edge_dict[key]
                if key in edge_dict.keys()
                else template_edge[key]
            )
            for key in template_edge.keys()
        }
        return edge_dict

    def from_dict(self, data):
        """Initialize the DAG from a dictionary representation.

        Parameters
        ----------
        data : dict
            A dictionary representation of the fitting diagram.
            e.g.:
            {
                "nodes": [
                    {"id": "1", "name": "node1", "action": "scale"},
                    {"id": "2", "name": "node2", "action": "alpha"},
                    {"id": "3", "name": "node3", "action": "all"},
                ],
                "edges": [
                {"source": "1", "target": "2"},
                {"source": "2", "target": "3"}
                ],
            }
            action field can also be a list, or string with comma-separated
            values.
            e.g.:
            {"id": "1", "name": "node1", "action": ["scale", "alpha"]}
            {"id": "2", "name": "node2", "action": "scale, alpha"}
        """
        self.clear()
        for node_content in data["nodes"]:
            action = node_content["action"]
            if isinstance(action, str):
                node_content["action"] = [v.strip() for v in action.split(",")]
            elif isinstance(action, list):
                node_content["action"] = action
            else:
                raise TypeError(
                    "Only str and list of str are supported for desginating "
                    "actions."
                )
            node_content = self.furnish_node_dict(node_content)
            node_id = node_content.get("id", str(uuid.uuid4()))
            self.add_node(node_id, **node_content)
        for edge in data["edges"]:
            edge = self.furnish_edge_dict(edge)
            self.add_edge(edge.pop("source"), edge.pop("target"), **edge)
        self._update_name_to_id()

    def from_str(self, dag_str):
        """Parse a linear DAG from a string representation.

        Parameters
        ----------
        diag_str : str
            String representation of the fitting diagram.
            E.g. "scale->alpha->a->qdamp->all"
            Each field can also be comma-separated values.
            E.g. "scale,alpha->a->qdamp->all"
        """
        self.clear()
        actions = [
            [v.strip() for v in value.split(",")]
            for value in dag_str.split("->")
        ]
        node_content = {"action": actions[0]}
        node_content = self.furnish_node_dict(node_content)
        parent_node_id = str(uuid.uuid4())
        self.add_node(parent_node_id, **node_content)
        for i in range(1, len(actions)):
            node_content = {"action": actions[i]}
            node_content = self.furnish_node_dict(node_content)
            child_node_id = str(uuid.uuid4())
            self.add_node(child_node_id, **node_content)
            edge = self.furnish_edge_dict({})
            self.add_edge(parent_node_id, child_node_id, **edge)
            parent_node_id = child_node_id
        self._update_name_to_id()

    def copy(
        self, with_payload=False, with_same_id=True, return_type="networkx"
    ):
        """Create a clean copy of the DAG."""
        if return_type == "networkx":
            graph = nx.DiGraph()
        elif return_type == "FitDAG":
            graph = FitDAG()
        else:
            raise KeyError(f"Unidentified type: {return_type}")
        id_maps = {}
        for node_id, node_content in self.nodes(data=True):
            node_content["buffer"] = None
            if not with_payload:
                node_content["payload"] = None
            if not with_same_id:
                new_node_id = str(uuid.uuid4())
                the_node_id = new_node_id
            else:
                the_node_id = node_id
            id_maps[node_id] = the_node_id
            graph.add_node(the_node_id, **node_content)

        for u, v, edge_content in self.edges(data=True):
            graph.add_edge(id_maps[u], id_maps[v], **edge_content)

        if return_type == "FitDAG":
            graph._update_name_to_id()

        return graph

    def to_json(self, filename="graph.json"):
        graph = self.copy(with_payload=True, with_same_id=True)
        data = node_link_data(
            graph,
            source="source",
            target="target",
            name="id",
            edges="edges",
            nodes="nodes",
        )
        with open(filename, "w") as f:
            json.dump(data, f, indent=2)

    def from_json(self, filename):
        with open(filename, "r") as f:
            graph_dict = json.load(f)
        self.from_dict(graph_dict)

    def render(self, filename="graph.html"):
        """Show the DAG structure."""
        from pyvis.network import Network

        net = Network(
            directed=True,
            notebook=False,
            cdn_resources="remote",
        )
        graph = self.copy(with_payload=False)
        node_ids, node_lables = [], []
        for node_id, node_content in graph.nodes(data=True):
            node_ids.append(node_id)
            node_lables.append(node_content["name"])
        net.add_nodes(node_ids, label=node_lables)
        net.add_edges(graph.edges())
        # Save and render
        # net.write_html(filename)
        net.show(filename, notebook=False)

    def clear(self):
        super().clear()
        self.name_to_id = {}
